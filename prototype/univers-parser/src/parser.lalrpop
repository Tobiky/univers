use crate::ast::{
  core::*,
  types::*,
  expressions::*,
  functions::*,
  statements::*,
};

grammar;

match {
    // Skip comments
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },
} else {
    // Allow matching of other terminals
    _
}

Identity: Identity<'input> =
    @L r"[_a-zA-Z][_a-zA-Z0-9]*" @R =>
      Identity::new(<>);

// Helper taken from
// https://github.com/lalrpop/lalrpop/blob/b777a6a884052d6283971f71b3ba453aa6d417ab/lalrpop/src/parser/lrgrammar.lalrpop#L447
Comma<E>: Vec<E> =
    <v0:(<E> ",")*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

Type: TypeToken<'input> = {
    <l:@L> <token: Identity> <r:@R> => 
        TypeToken {
            location: (l, r),
            token: Type::Named(token)
        },

    // lambda/function type annotation
}

TypeHint: Option<TypeToken<'input>> = (":" <Type>)?;

Parameter: Parameter<'input> = Identity TypeHint;

FunctionCall: FunctionCallToken<'input> = {
    <l: @L> <name: Identity> "(" <arguments: Comma<Expression>> ")" <r: @R> =>
      FunctionCallToken {
          location: (l, r),
          name,
          arguments
      }
};

MemberAccess: MemberAccessToken<'input> = {
    <l: @L> <source: Expression> "." <function: FunctionCall> <r: @R> =>
        MemberAccessToken { 
            location: (l, r),
            source: Box::new(source),
            access: MemberAccess::Function(function)
        },


    <l: @L> <source: Expression> "." <field: Identity> <r: @R> =>
        MemberAccessToken { 
            location: (l, r),
            source: Box::new(source),
            access: MemberAccess::Field(field)
        },
};

// Other recusive expressions
RecursiveExpression: ExpressionToken<'input> = {
    "(" <Expression> ")",

    <l: @L> <call: FunctionCall> <r: @R> =>
        ExpressionToken {
            location: (l, r),
            token: Expression::Call(call),
        },
    
    // FIXME: hangs
    <l: @L> <access: MemberAccess> <r: @R> =>
        ExpressionToken {
            location: (l, r),
            token: Expression::MemberAccess(access),
        },
};

// Literals
LiteralExpression: ExpressionToken<'input> = {
    <l: @L> <s: r"\d+"> <r: @R> => 
        ExpressionToken::literal_at(l, s, "int", r),

    <l: @L> <s: r"\d*\.\d*"> <r: @R> => 
        ExpressionToken::literal_at(l, s, "float", r),

    // FIXME: only " ' \ n t allowed escape sequences currently
    <l: @L> <s: r#""(?:[ -~&&[^'"\\]]|\\['"nt\\])*""#> <r: @R> => 
        ExpressionToken::literal_at(l, s, "str", r),
};

Expression: ExpressionToken<'input> = {
#[precedence(level="0")]
    RecursiveExpression,
    LiteralExpression,

#[precedence(level="1")] #[assoc(side="right")]
    <l: @L> "!" <ro: @R> <e: Expression> <r: @R> => UnOp::BooleanNot.expression(<>),
    <l: @L> "-" <ro: @R> <e: Expression> <r: @R> => UnOp::Negative.expression(<>),
    <l: @L> "~" <ro: @R> <e: Expression> <r: @R> => UnOp::LogicalInverse.expression(<>),

    // * / %
#[precedence(level="2")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "*" <ro: @R> <e2: Expression> <r: @R> => BinOp::Mul.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> "/" <ro: @R> <e2: Expression> <r: @R> => BinOp::Div.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> "%" <ro: @R> <e2: Expression> <r: @R> => BinOp::Mod.expression(<>),

    // + -
#[precedence(level="3")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "+" <ro: @R> <e2: Expression> <r: @R> => BinOp::Add.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> "-" <ro: @R> <e2: Expression> <r: @R> => BinOp::Sub.expression(<>),

    // << >>
#[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> ">>" <ro: @R> <e2: Expression> <r: @R> => BinOp::RightShift.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> "<<" <ro: @R> <e2: Expression> <r: @R> => BinOp::LeftShift.expression(<>),

    // < > <= >=
#[precedence(level="5")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "<" <ro: @R> <e2: Expression> <r: @R> => BinOp::Less.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> ">" <ro: @R> <e2: Expression> <r: @R> => BinOp::Greater.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> "<=" <ro: @R> <e2: Expression> <r: @R> => BinOp::LessOrEqual.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> ">=" <ro: @R> <e2: Expression> <r: @R> => BinOp::GreaterOrEqual.expression(<>),

    // != ==
#[precedence(level="6")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "!=" <ro: @R> <e2: Expression> <r: @R> => BinOp::NotEqual.expression(<>),
    <l: @L> <e1: Expression> <lo: @L> "==" <ro: @R> <e2: Expression> <r: @R> => BinOp::Equal.expression(<>),

    // &
#[precedence(level="7")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "&" <ro: @R> <e2: Expression> <r: @R> => BinOp::LogicalAnd.expression(<>),

    // ^
#[precedence(level="8")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "^" <ro: @R> <e2: Expression> <r: @R> => BinOp::LogicalXor.expression(<>),

    // |
#[precedence(level="9")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "|" <ro: @R> <e2: Expression> <r: @R> => BinOp::LogicalOr.expression(<>),

    // &&
#[precedence(level="10")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "&&" <ro: @R> <e2: Expression> <r: @R> => BinOp::BooleanAnd.expression(<>),

    // ^^
#[precedence(level="11")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "^^" <ro: @R> <e2: Expression> <r: @R> => BinOp::BooleanXor.expression(<>),

    // ||
#[precedence(level="12")] #[assoc(side="left")]
    <l: @L> <e1: Expression> <lo: @L> "||" <ro: @R> <e2: Expression> <r: @R> => BinOp::BooleanOr.expression(<>),
            };

Function: FunctionToken<'input> = {
  // Parameters: fnc add(a, b) { return a + b }
    <l: @L> "fnc" <name: Identity> "(" <parameters: Comma<Parameter>> ")" <return_type: TypeHint>
    "{"
        <body: Statement*> 
    "}" <r: @R> =>
        FunctionToken {
          location: (l, r),
          name,
          parameters,
          return_type,
          body 
        },

    // No parameters: fnc f { }
    <l: @L> "fnc" <name: Identity> <return_type: TypeHint> 
    "{" 
        <body: Statement*> 
    "}" <r: @R> =>
        FunctionToken {
            location: (l, r),
            name,
            parameters: vec![],
            return_type,
            body
        },
};

// TODO: add short syntax
CommandOptionType: CommandOptionTypeToken = {
  <l: @L> "flag" <r: @R> => CommandOptionTypeToken {
    location: (l, r),
    token: CommandOptionType::Flag,
  },
  <l: @L> "arg" <r: @R> => CommandOptionTypeToken {
    location: (l, r),
    token: CommandOptionType::Argument,
  },
};

// TODO: try to make comma seperation optional
CommandOption: CommandOptionToken<'input> = {
  <l: @L> <option_type: CommandOptionType> <name: Identity> "=" "{" <settings: (<Identity> "=" <Expression>)*> "}" <r: @R> => CommandOptionToken {
    location: (l, r),
    name,
    settings,
    option_type,
  }
};

Command: CommandToken<'input> = {
  <l: @L> "cmd" <name: Identity> "with" <options: Comma<CommandOption>> <rest_variable: ("rest" <Identity>)?> "{" <body: Statement*> "}" <r: @R> => CommandToken{
    location: (l, r),
    name,
    options,
    rest_variable,
    body
  },

  <l: @L> "cmd" <name: Identity> "with" <rest_variable: Identity> "{" <body: Statement*> "}" <r: @R> => CommandToken{
    location: (l, r),
    name,
    options: vec![],
    rest_variable: Some(rest_variable),
    body
  }
};


AssignShortSyntax: StatementToken<'input> = {
  <l: @L> <name: Identity> <lo: @L> "+=" <ro: @R> <e: Expression> <r: @R> => BinOp::Add.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "-=" <ro: @R> <e: Expression> <r: @R> => BinOp::Sub.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "*=" <ro: @R> <e: Expression> <r: @R> => BinOp::Mul.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "/=" <ro: @R> <e: Expression> <r: @R> => BinOp::Div.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "%=" <ro: @R> <e: Expression> <r: @R> => BinOp::Mod.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "&=" <ro: @R> <e: Expression> <r: @R> => BinOp::LogicalAnd.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "|=" <ro: @R> <e: Expression> <r: @R> => BinOp::LogicalOr.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "^=" <ro: @R> <e: Expression> <r: @R> => BinOp::LogicalXor.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "<<=" <ro: @R> <e: Expression> <r: @R> => BinOp::LeftShift.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> ">>=" <ro: @R> <e: Expression> <r: @R> => BinOp::RightShift.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "===" <ro: @R> <e: Expression> <r: @R> => BinOp::Equal.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "!==" <ro: @R> <e: Expression> <r: @R> => BinOp::NotEqual.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> ">==" <ro: @R> <e: Expression> <r: @R> => BinOp::GreaterOrEqual.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "<==" <ro: @R> <e: Expression> <r: @R> => BinOp::LessOrEqual.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "<=" <ro: @R> <e: Expression> <r: @R> => BinOp::Less.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> ">=" <ro: @R> <e: Expression> <r: @R> => BinOp::Greater.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "&&=" <ro: @R> <e: Expression> <r: @R> => BinOp::BooleanAnd.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "||=" <ro: @R> <e: Expression> <r: @R> => BinOp::BooleanOr.assign_statement(<>),

  <l: @L> <name: Identity> <lo: @L> "^^=" <ro: @R> <e: Expression> <r: @R> => BinOp::BooleanXor.assign_statement(<>),
}

BaseStatement: StatementToken<'input> = {
    <l: @L> <var: Identity> "=" <val: Expression> <r: @R> =>
        StatementToken {
            location: (l, r),
            token: Statement::Assign(var, val),
        },

    AssignShortSyntax,

    <l: @L> <e: Expression> <r: @R> =>
        StatementToken {
            location: (l, r),
            token: Statement::Expression(e),
        },

    <l: @L> <f: Function> <r: @R> => 
        StatementToken {
            location: (l, r),
            token: Statement::FunctionDeclaration(f),
        },

    <l: @L> <c: Command> <r: @R> => 
        StatementToken {
            location: (l, r),
            token: Statement::CommandDeclaration(c),
        },
};

Statement: StatementToken<'input> = <BaseStatement> ";";

pub Program: Program<'input> = Statement*;
